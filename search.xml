<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用go-swagger为golang API自动生成swagger文档]]></title>
    <url>%2Farticle%2F6b03ec87%2F</url>
    <content type="text"><![CDATA[什么是swagger？Swagger是一个简单但功能强大的API表达工具。它具有地球上最大的API工具生态系统，数以千计的开发人员，使用几乎所有的现代编程语言，都在支持和使用Swagger。使用Swagger生成API，我们可以得到交互式文档，自动生成代码的SDK以及API的发现特性等。 swagger文档长啥样？一个最简单的swagger文档示例： 12345678910111213swagger: "2.0"info: version: 1.0.0 title: Simple API description: A simple API to learn how to write OpenAPI Specificationschemes: - httpshost: simple.apibasePath: /openapi101paths: &#123;&#125; Tips:阅读本文前提是假设你已经了解了如何编写swagger文档，当然，如果还不了解也没关系，可以去swagger官网查看文档进行学习，并且这里还有一套《Swagger从入门到精通》附上. 本文背景介绍​ 写作本文的原因是因为公司要求api文档都使用 swagger格式，项目是用golang编写的，作为一个懒癌程序员，怎么能够忍受去编写这么复杂的swagger文档呢？有没有一键生成的工具呢？google一下，还真有,那就是go-swagger项目。go-swagger众多特色功能之一就是Generate a spec from source,即通过源码生成文档，很符合我的需求。 下面就简单介绍下如何为项目加上swagger注释，然后一键生成API文档 开始之前需要安装两个工具： swagger-editor:用于编写swagger文档，UI展示，生成代码等… go-swagger:用于一键生成API文档 安装swagger-editor,我这里使用docker运行，其他安装方式，请查看官方文档： 12docker pull swaggerapi/swagger-editordocker run --rm -p 80:8080 swaggerapi/swagger-editor 安装go-swagger,我这边使用brew安装，其他安装方式，请查看官方文档 12brew tap go-swagger/go-swaggerbrew install go-swagger 好了，现在终于开始正题：start coding!!! 开始编写注释1.假设有一个user.server，提供一些REST API，用于对用户数据的增删改查。 比如这里有一个getOneUser接口，是查询用户信息的： 12345678910111213141516171819202122232425262728293031323334353637package serviceimport ( "encoding/json" "fmt" "net/http" "strconv" "user.server/models" "crypto/md5" "errors" "github.com/Sirupsen/logrus" "github.com/gorilla/mux")type GetUserParam struct &#123; Id int `json:"id"`&#125;func GetOneUser(w http.ResponseWriter, r *http.Request) &#123; defer r.Body.Close() decoder := json.NewDecoder(r.Body) var param GetUserParam err := decoder.Decode(&amp;param) if err != nil &#123; WriteResponse(w, ErrorResponseCode, "request param is invalid, please check!", nil) return &#125; // get user from db user, err := models.GetOne(strconv.Itoa(param.Id)) if err != nil &#123; logrus.Warn(err) WriteResponse(w, ErrorResponseCode, "failed", nil) return &#125; WriteResponse(w, SuccessResponseCode, "success", user)&#125; 根据swagger文档规范，一个swagger文档首先要有swagger的版本和info信息。利用go-swagger只需要在声明package之前加上如下注释即可： 12345678910// Package classification User API.//// The purpose of this service is to provide an application// that is using plain go code to define an API//// Host: localhost// Version: 0.0.1//// swagger:metapackage service 然后在项目根目录下使用swagger generate spec -o ./swagger.json命令生成swagger.json文件： 此命令会找到main.go入口文件，然后遍历所有源码文件，解析然后生成swagger.json文件 12345678910&#123; "swagger": "2.0", "info": &#123; "description": "The purpose of this service is to provide an application\nthat is using plain go code to define an API", "title": "User API.", "version": "0.0.1" &#125;, "host": "localhost", "paths": &#123;&#125;&#125; 2.基本信息有了，然后就要有路由，请求，响应等，下面针对getOneUser接口编写swagger注释： 1234567891011121314151617181920212223242526272829303132333435// swagger:parameters getSingleUsertype GetUserParam struct &#123; // an id of user info // // Required: true // in: path Id int `json:"id"`&#125;func GetOneUser(w http.ResponseWriter, r *http.Request) &#123; // swagger:route GET /users/&#123;id&#125; users getSingleUser // // get a user by userID // // This will show a user info // // Responses: // 200: UserResponse decoder := json.NewDecoder(r.Body) var param GetUserParam err := decoder.Decode(&amp;param) if err != nil &#123; WriteResponse(w, ErrorResponseCode, "request param is invalid, please check!", nil) return &#125; // get user from db user, err := models.GetOne(strconv.Itoa(param.Id)) if err != nil &#123; logrus.Warn(err) WriteResponse(w, ErrorResponseCode, "failed", nil) return &#125; WriteResponse(w, SuccessResponseCode, "success", user)&#125; 可以看到在GetUserParam结构体上面加了一行swagger:parameters getSingleUser的注释信息，这是声明接口的入参注释，结构体内部的几行注释指明了id这个参数必填，并且查询参数id是在url path中。详细用法，参考: swagger:params 在GetOneUser函数中： swagger:route指明使用的http method，路由，以及标签和operation id,详细用法，参考： swagger:route Responses指明了返回值的code以及类型 然后再声明响应: 12345678910111213// User Info//// swagger:response UserResponsetype UserWapper struct &#123; // in: body Body ResponseMessage&#125;type ResponseMessage struct &#123; Code int `json:"code"` Message string `json:"message"` Data interface&#123;&#125; `json:"data"`&#125; 使用swagger:response语法声明返回值，其上两行是返回值的描述（我也不清楚，为啥描述信息要写在上面，欢迎解惑）,详细用法，参考； swagger:response 然后浏览器访问localhost,查看swagger-editor界面,点击工具栏中的File-&gt;Impoprt File上传刚才生成的 swagger.json文件，就可以看到界面： 这样一个简单的api文档就生成了 3.怎么样？是不是很简单？可是又感觉那里不对，嗯，注释都写在代码里了，很不美观，而且不易维护。想一下go-swagger的原理是扫描目录下的所有go文件，解析注释信息。那么是不是可以把api注释都集中写在单个文件内，统一管理，免得分散在各个源码文件内。 新建一个doc.go文件，这里还有一个接口是UpdateUser,那么我们在doc.go文件中声明此接口的api注释。先看一下UpdateUser接口的代码： 12345678910111213141516171819202122232425262728293031func UpdateUser(w http.ResponseWriter, r *http.Request) &#123; defer r.Body.Close() // decode body data into user struct decoder := json.NewDecoder(r.Body) user := models.User&#123;&#125; err := decoder.Decode(&amp;user) if err != nil &#123; WriteResponse(w, ErrorResponseCode, "user data is invalid, please check!", nil) return &#125; // check if user exists data, err := models.GetUserById(user.Id) if err != nil &#123; logrus.Warn(err) WriteResponse(w, ErrorResponseCode, "query user failed", nil) return &#125; if data.Id == 0 &#123; WriteResponse(w, ErrorResponseCode, "user not exists, no need to update", nil) return &#125; // update _, err = models.Update(user) if err != nil &#123; WriteResponse(w, ErrorResponseCode, "update user data failed, please try again!", nil) return &#125; WriteResponse(w, SuccessResponseCode, "update user data success!", nil)&#125; 然后再doc.go文件中编写如下声明： 1234567891011121314151617181920212223242526package serviceimport "user.server/models"// swagger:parameters UpdateUserResponseWrappertype UpdateUserRequest struct &#123; // in: body Body models.User&#125;// Update User Info//// swagger:response UpdateUserResponseWrappertype UpdateUserResponseWrapper struct &#123; // in: body Body ResponseMessage&#125;// swagger:route POST /users users UpdateUserResponseWrapper//// Update User//// This will update user info//// Responses:// 200: UpdateUserResponseWrapper 这样就把api声明注释给抽离出来了，然后使用命令swagger generate spec -o ./swagger.json生成json文件,就可以看到这样的结果： 很简单吧，参照文档编写几行注释，然后一个命令生成API文档。懒癌程序员福音~ 本文所有示例代码托管在这里 参考： swagger官方Doc Swagger从入门到精通 go-swagger文档 go-swagger的github主页]]></content>
      <tags>
        <tag>golang</tag>
        <tag>swagger</tag>
        <tag>go-swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用automator上传图片到腾讯云]]></title>
    <url>%2Farticle%2F38b3f2da%2F</url>
    <content type="text"><![CDATA[背景前段时间折腾了一下hexo博客，部署了Github Pages，设置了自己的域名转发，添加了https，仿佛万事具备，只差写博客了。然而发现博客配图还是个问题，因为markdown添加图片的时候，我想使用cdn，而不是本地图片。 于是考察了一些可以作为图床的云服务商，比如七牛，sm.ms，腾讯云 。对比之后发现七牛不支持https，sm.ms完全免费，但功能似乎比较少，腾讯云的话有免费的几十G空间（具体多少我忘了）还提供https。嗯就用腾讯云吧。 图床选好了，那么上传图床的工具呢？都说iPic是个图床神器，最近还支持了腾讯云，不过需要付费。我需要的是一个免费版的，找了半天也没发现支持腾讯云的图床工具。作为一名coder，这怎么能忍？依稀记得好友的博客中有写使用automator上传图片到sm.ms,于是我借鉴(copy)了一下，就有了本文。不同之处在于我这里使用的是腾讯云的python sdk进行上传。 思路使用automator上传图片的思路： 点击本地图片，右键选择automator创建的服务 调用预先编写好的脚本进行上传 上传后将url写入剪贴板 在markdown编辑器中直接粘贴享用 实现步骤打开automator，选择新建服务： 然后在“实用工具”中，找到“拷贝至剪切板”拖拽到右侧工作流程，这样，当我们选中图片的时候，就会将图片的本地路径设置到剪贴板中： 我们需要在这个创建服务的过程中进行实际测试，因此可以将“获得指定的访达(finder)项目”这个使用工具添加到右侧的工作流中，放在顶部，并添加几张图片作为测试用（后面需要再删除的），如下图： 然后点击右上角的运行按钮，运行完成后，查看自己的剪贴板内容，就会发现剪贴板内容正是图片的路径。 现在图片路径有了，再添加一个shell脚本的工作流，在脚本里面获取剪贴板里面的图片路径，然后进行上传，再将上传后的腾讯云的图片地址设置进剪贴板里，就行了。 将“运行shell脚本”这个工作流添加到右边，作为第三个工作流,并且选择python作为默认shell，如下图： 上图中的python代码所做的事情就是上传图片，并设置剪贴板内容，code如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# -*- coding=utf-8from qcloud_cos import CosConfigfrom qcloud_cos import CosS3Clientimport osimport subprocess# 上传腾讯云需要的相关配置，可在这里查看：https://console.cloud.tencent.com/cam/capisecret_id = 'your_cos_secret_id' # 此处填入腾讯云的secret_id，secret_key = 'your_cos_secret_key' # 此处填入腾讯云的secret_keyapp_id = 'your_app_id' # 此处填入app_idregion = 'your_region' # 此处填入对象存储的地区token = '' # 使用临时秘钥需要传入 Token，默认为空，可不填bucket_name = 'your_bucket_name'bucket = bucket_name + '-' + app_id # Bucket由bucketname-appid组成legal_extensions = ['.jpg', '.jpeg', '.png', 'gif']# 获取剪贴板内容def getClipboardData(): p = subprocess.Popen(['pbpaste'], stdout=subprocess.PIPE) retcode = p.wait() data = p.stdout.read() return data# 设置剪贴板内容def setClipboardData(data): p = subprocess.Popen(['pbcopy'], stdin=subprocess.PIPE) p.stdin.write(data) p.stdin.close() retcode = p.wait()# 判断扩展名是否合法def validate_image(path): extension = os.path.splitext(path)[1] if extension in legal_extensions: return True else: return False# 上传至腾讯云def upload(file_name, filepath): config = CosConfig(Appid=app_id, Secret_id=secret_id, Secret_key=secret_key, Region=region, Token=token) # 获取客户端对象 client = CosS3Client(config) with open(filepath, 'rb') as fp: response = client.put_object( Bucket=bucket, Body=fp, Key=file_name, StorageClass='STANDARD', ContentType='text/html; charset=utf-8' ) # print responsedef main(): contents = getClipboardData().split("\n") uploaded_url = "" for path in contents: if validate_image(path): file_name = os.path.basename(path) upload(file_name, path) # 拼接成markdown的image链接格式 uploaded_url += '![](' + 'https://' + bucket + '.cos.' + region + '.myqcloud.com/' + file_name + ")\n" # 将url设置到剪贴板中 setClipboardData(uploaded_url)main() 代码量不多，其中上传函数upload的实现是使用的官方sdk.如何安装sdk，以及更多使用方式，请参考官方文档 tips: 这里运行的过程中不但可以单步调试，还可以查看程序输出，以便进行测试： 到这里上传功能已经实现了，如果再加一个上传完成后给个提示就更好了。 将“显示通知”这个工作流添加到右侧工作区，设置通知内容，然后执行，就会看到通知提示 至此，功能已经实现，现在把第一个工作流“获取指定的finder项目”删除。保存这个服务，并取一个名字： 然后随便找一个图片，右键呼出菜单，就会看到我们刚创建的服务，不出意外，就可以正常使用了： 如果下次再想对这个服务进行编辑的话，该去哪里找呢？其实这些自定义的服务是放在~/Library/Services路径下的: 12&gt; ls ~/Library/Services上传至腾讯云.workflow 到这里，这个上传图片的automator就算完成了。不足之处就是只能对磁盘上的图片文件进行操作。无法对截图进行操作。其实理论上只要能获取剪贴板的内容，截图上传也是可以实现的。 参考： 使用 Automator 上传图片到 sm.ms 腾讯云对象存储python sdk 文档]]></content>
      <tags>
        <tag>automator</tag>
        <tag>腾讯云</tag>
        <tag>mac</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用笔记]]></title>
    <url>%2Farticle%2Fd6ed9cc7%2F</url>
    <content type="text"><![CDATA[添加阅读次数统计 参考next主题文档，使用leanCloud来统计 1.注册leancloud账号，获取appId和appKey,具体细节可以参考这里 2.编辑主题配置文件，修改配项leancloud_visitors 123456leancloud_visitors: enable: true app_id: &lt;your_app_id&gt; app_key: &lt;your_app_key&gt; security: true betterPerformance: false 然后重新部署hexo博客，列表页已经有了阅读次数，但是详情页报错：阅读次数： Counter not initialized! See more at console err msg.查看控制台报错，有两种方式解决： 使用hexo-leancloud-counter-security插件 设置leancloud_visitors.security = false 我这里选择第二种。设置以后重新部署hexo，即可看到阅读次数的统计。 添加音乐添加音乐很简单，只需要在markdown文件中加入iframe标签即可，示例： 1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&amp;id=34578162&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt; 然后需要做的就是将上面链接中的id的值替换成目标歌曲的id即可，可以去网易云音乐搜索音乐，从链接中获取id。更多玩法参考这里 开启图片点击预览1.NexT主题是支持图片预览的，使用的是fancyBox这个js库,要做的就是开启这个功能即可。 2.打开主题配置文件,找到fancybox: false这个配置项，修改为true即可。 参考： 为NexT主题添加文章阅读量统计功能 NexT官方文档 Hexo 博客补丁]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
